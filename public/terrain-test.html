<!DOCTYPE html>
<html lang="en">
	<head>
		<title>three.js - terrain test with GLB</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<style>
			* {
				margin: 0;
				padding: 0;
				box-sizing: border-box;
			}

			body {
				overflow: hidden;
				font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
				background: #201919;
			}

			#info {
				position: absolute;
				top: 0;
				left: 0;
				width: 100%;
				padding: 20px;
				pointer-events: none;
				z-index: 100;
			}

			#info a {
				color: #fff;
				text-decoration: none;
			}

			.title-wrapper {
				display: flex;
				align-items: center;
				gap: 10px;
				margin-bottom: 10px;
			}

			.title-wrapper a {
				font-size: 24px;
				font-weight: bold;
			}

			.title-wrapper span {
				font-size: 18px;
				opacity: 0.8;
			}

			small {
				display: block;
				opacity: 0.7;
				font-size: 12px;
			}

			small a {
				text-decoration: underline;
			}
		</style>
	</head>
	<body>

		<div id="info">
			<div class="title-wrapper">
				<a href="https://threejs.org/" target="_blank" rel="noopener">three.js</a><span>Terrain Test with GLB</span>
			</div>

			<small>
				Drag to move the terrain. Tile-based rendering - only visible tiles are loaded. Configure CDN in tileConfig.cdnBaseUrl. Based on <a href="https://threejs-journey.com/lessons/procedural-terrain-shader" target="_blank" rel="noopener">Three.js Journey</a> lessons.
			</small>
		</div>

		<script type="importmap">
			{
				"imports": {
					"three": "https://cdn.jsdelivr.net/npm/three@0.153.0/build/three.module.js",
					"three/addons/": "https://cdn.jsdelivr.net/npm/three@0.153.0/examples/jsm/"
				}
			}
		</script>

		<script type="module">

			import * as THREE from 'three';
			import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
			import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
			import { RGBELoader } from 'three/addons/loaders/RGBELoader.js';

			let camera, scene, renderer, controls, drag;
			
			// Tile system configuration
			const tileConfig = {
				tilesPerSide: 301, // Total tiles in texture (301x301)
				tileSizeInUnits: 2.0, // Size of each tile in scene units
				visibleTiles: 4, // Show 4x4 tiles at a time (grid size)
				
				// CDN Configuration - Update this with your tile storage location
				// Options:
				// - Google Drive: 'https://drive.google.com/uc?export=view&id=YOUR_FILE_ID'
				// - AWS S3: 'https://your-bucket.s3.amazonaws.com/tiles/'
				// - Cloudinary: 'https://res.cloudinary.com/your-cloud/image/upload/tiles/'
				// - Self-hosted: '/assets/tiles/'
				cdnBaseUrl: '', // Leave empty to use local path, or set to your CDN
				tilePathFormat: 'tile_{x}_{y}.png', // Format: tile_2333_5375.png
				// For individual tiles, you might use: '13_{x}_{y}.png' (zoom_x_y.png)
				
				// Tile coordinate range (from documentation)
				tileXStart: 2333, // Starting X tile coordinate
				tileYStart: 5375, // Starting Y tile coordinate
			};
			
			// Tile management
			const tileManager = {
				tiles: new Map(), // Map of "x_y" -> mesh
				loadingTiles: new Set(), // Tiles currently loading
				textureLoader: new THREE.TextureLoader(),
				tileGroup: null, // Group containing all tile meshes
				
				// Get tile key from coordinates
				getTileKey(x, y) {
					return `${x}_${y}`;
				},
				
				// Get tile URL
				getTileUrl(tileX, tileY) {
					if (tileConfig.cdnBaseUrl) {
						const filename = tileConfig.tilePathFormat
							.replace('{x}', tileX)
							.replace('{y}', tileY);
						return `${tileConfig.cdnBaseUrl}${filename}`;
					} else {
						// Local path - adjust based on your structure
						const filename = tileConfig.tilePathFormat
							.replace('{x}', tileX)
							.replace('{y}', tileY);
						return `./assets/tiles/${filename}`;
					}
				},
				
				// Create a single tile mesh
				createTileMesh(tileX, tileY) {
					const geometry = new THREE.PlaneGeometry(
						tileConfig.tileSizeInUnits,
						tileConfig.tileSizeInUnits,
						1, 1
					);
					geometry.rotateX(-Math.PI * 0.5); // Rotate to horizontal
					
					// Create material with placeholder color
					const material = new THREE.MeshStandardMaterial({
						color: 0x888888, // Gray placeholder
						side: THREE.DoubleSide
					});
					
					const mesh = new THREE.Mesh(geometry, material);
					mesh.receiveShadow = true;
					mesh.castShadow = false;
					
					// Position tile in world space
					const worldX = (tileX - tileConfig.tileXStart) * tileConfig.tileSizeInUnits;
					const worldZ = (tileY - tileConfig.tileYStart) * tileConfig.tileSizeInUnits;
					mesh.position.set(worldX, 0, worldZ);
					
					// Store tile coordinates for reference
					mesh.userData.tileX = tileX;
					mesh.userData.tileY = tileY;
					
					return mesh;
				},
				
				// Load texture for a tile
				loadTileTexture(tileX, tileY, mesh) {
					const tileKey = this.getTileKey(tileX, tileY);
					
					// Prevent duplicate loading
					if (this.loadingTiles.has(tileKey)) {
						return;
					}
					
					this.loadingTiles.add(tileKey);
					const url = this.getTileUrl(tileX, tileY);
					
					console.log(`Loading tile texture: ${tileKey} from ${url}`);
					
					this.textureLoader.load(
						url,
						(texture) => {
							// Success - apply texture
							texture.wrapS = THREE.ClampToEdgeWrapping;
							texture.wrapT = THREE.ClampToEdgeWrapping;
							texture.flipY = false;
							
							mesh.material.map = texture;
							mesh.material.needsUpdate = true;
							
							console.log(`âœ“ Tile ${tileKey} loaded successfully`);
							this.loadingTiles.delete(tileKey);
						},
						undefined,
						(error) => {
							// Error - keep placeholder
							console.warn(`Failed to load tile ${tileKey}:`, error);
							this.loadingTiles.delete(tileKey);
						}
					);
				},
				
				// Update visible tiles based on current view position
				updateVisibleTiles(centerTileX, centerTileY) {
					if (!this.tileGroup) {
						this.tileGroup = new THREE.Group();
						scene.add(this.tileGroup);
					}
					
					// Calculate which tiles should be visible
					const halfVisible = Math.floor(tileConfig.visibleTiles / 2);
					const startX = Math.max(
						tileConfig.tileXStart,
						Math.min(
							tileConfig.tileXStart + tileConfig.tilesPerSide - tileConfig.visibleTiles,
							centerTileX - halfVisible
						)
					);
					const startY = Math.max(
						tileConfig.tileYStart,
						Math.min(
							tileConfig.tileYStart + tileConfig.tilesPerSide - tileConfig.visibleTiles,
							centerTileY - halfVisible
						)
					);
					
					const visibleTiles = new Set();
					
					// Create/update visible tiles
					for (let y = 0; y < tileConfig.visibleTiles; y++) {
						for (let x = 0; x < tileConfig.visibleTiles; x++) {
							const tileX = startX + x;
							const tileY = startY + y;
							const tileKey = this.getTileKey(tileX, tileY);
							
							visibleTiles.add(tileKey);
							
							// Get or create tile mesh
							let mesh = this.tiles.get(tileKey);
							if (!mesh) {
								mesh = this.createTileMesh(tileX, tileY);
								this.tiles.set(tileKey, mesh);
								this.tileGroup.add(mesh);
								
								// Load texture for this tile
								this.loadTileTexture(tileX, tileY, mesh);
							}
							
							// Ensure tile is visible
							mesh.visible = true;
						}
					}
					
					// Hide tiles that are no longer visible
					for (const [tileKey, mesh] of this.tiles) {
						if (!visibleTiles.has(tileKey)) {
							mesh.visible = false;
						}
					}
					
					console.log(`Visible tiles updated: ${visibleTiles.size} tiles, center: (${centerTileX}, ${centerTileY})`);
				}
			};
			
			// Current view position in tile coordinates
			let currentTileX = tileConfig.tileXStart + Math.floor(tileConfig.tilesPerSide / 2);
			let currentTileY = tileConfig.tileYStart + Math.floor(tileConfig.tilesPerSide / 2);

			init();

			function init() {

				camera = new THREE.PerspectiveCamera( 35, window.innerWidth / window.innerHeight, 0.1, 500 );
				// Position camera to view the visible tile area nicely
				camera.position.set( 0, 15, 15 );
				camera.lookAt( 0, 0, 0 );
				console.log('Camera initialized at:', camera.position);

				scene = new THREE.Scene();
				scene.background = new THREE.Color( 0x201919 );

				// environment

				const rgbeLoader = new RGBELoader();
				rgbeLoader.load( './assets/textures/envmap.hdr', ( environmentMap ) => {

					environmentMap.mapping = THREE.EquirectangularReflectionMapping;

					scene.background = environmentMap;
					scene.backgroundBlurriness = 0.5;
					scene.environment = environmentMap;
			
				} );

				// lights
			
				// Ambient light for overall illumination
				const ambientLight = new THREE.AmbientLight( '#ffffff', 0.5 );
				scene.add( ambientLight );
			
				const directionalLight = new THREE.DirectionalLight( '#ffffff', 2 );
				directionalLight.position.set( 6.25, 3, 4 );
				directionalLight.castShadow = true;
				directionalLight.shadow.mapSize.set( 1024, 1024 );
				directionalLight.shadow.camera.near = 0.1;
				directionalLight.shadow.camera.far = 150; // Increased for larger terrain
				directionalLight.shadow.camera.top = 50; // Increased for larger terrain
				directionalLight.shadow.camera.right = 50;
				directionalLight.shadow.camera.bottom = - 50;
				directionalLight.shadow.camera.left = - 50;
				directionalLight.shadow.normalBias = 0.05;
				directionalLight.shadow.bias = 0;
				scene.add( directionalLight );

				// Initialize tile-based terrain system
				// Calculate visible terrain size for drag plane
				const visibleTerrainSize = tileConfig.visibleTiles * tileConfig.tileSizeInUnits;
				
				// Initialize visible tiles at center
				tileManager.updateVisibleTiles(currentTileX, currentTileY);
				
				console.log('Tile-based terrain system initialized:', {
					visibleTiles: `${tileConfig.visibleTiles}x${tileConfig.visibleTiles}`,
					visibleTerrainSize: `${visibleTerrainSize} units`,
					startingPosition: `(${currentTileX}, ${currentTileY})`
				});

				// Remove water plane - not needed for terrain test

				// drag

				drag = {};
				drag.screenCoords = new THREE.Vector2();
				drag.prevWorldCoords = new THREE.Vector3();
				drag.worldCoords = new THREE.Vector3();
				drag.raycaster = new THREE.Raycaster();
				drag.down = false;
				drag.hover = false;

				// Create drag plane matching visible terrain size
				// Use a larger plane to make dragging easier
				const dragPlaneSize = visibleTerrainSize * 2; // Larger for easier dragging
				drag.object = new THREE.Mesh( 
					new THREE.PlaneGeometry( dragPlaneSize, dragPlaneSize, 1, 1 ), 
					new THREE.MeshBasicMaterial( { visible: false, side: THREE.DoubleSide } ) 
				);
				drag.object.rotation.x = - Math.PI * 0.5;
				drag.object.position.y = 0; // At ground level
				drag.object.visible = false;
				scene.add( drag.object );
				console.log('Drag plane created:', {
					size: dragPlaneSize,
					position: drag.object.position
				});

				drag.getIntersect = () => {

					drag.raycaster.setFromCamera( drag.screenCoords, camera );
					const intersects = drag.raycaster.intersectObject( drag.object );
					if ( intersects.length )
						return intersects[ 0 ];

					return null;

				};

				drag.update = () => {

					const intersect = drag.getIntersect();

					if ( intersect ) {

						drag.hover = true;

						if ( ! drag.down )
							renderer.domElement.style.cursor = 'grab';

					} else {

						drag.hover = false;
						renderer.domElement.style.cursor = 'default';

					}

					if ( drag.hover && drag.down ) {

						drag.worldCoords.copy( intersect.point );
						
						// Calculate delta (movement since last frame)
						// delta = previous - current (so dragging right gives negative delta.x)
						const delta = new THREE.Vector3();
						delta.subVectors( drag.prevWorldCoords, drag.worldCoords );

						// Convert world space movement to tile coordinate changes
						// When dragging right (positive delta.x), we want to see tiles to the right
						// This means decreasing currentTileX (moving viewport left in tile space)
						const tileDeltaX = -delta.x / tileConfig.tileSizeInUnits;
						const tileDeltaZ = -delta.z / tileConfig.tileSizeInUnits;
						
						// Update tile coordinates
						currentTileX += tileDeltaX;
						currentTileY += tileDeltaZ;
						
						// Clamp to valid tile range
						const minTileX = tileConfig.tileXStart;
						const maxTileX = tileConfig.tileXStart + tileConfig.tilesPerSide - 1;
						const minTileY = tileConfig.tileYStart;
						const maxTileY = tileConfig.tileYStart + tileConfig.tilesPerSide - 1;
						
						currentTileX = Math.max( minTileX, Math.min( maxTileX, Math.round( currentTileX ) ) );
						currentTileY = Math.max( minTileY, Math.min( maxTileY, Math.round( currentTileY ) ) );

						// Update visible tiles based on new position
						tileManager.updateVisibleTiles( currentTileX, currentTileY );
						
						// Update previous coordinates for next frame (must be after using delta)
						drag.prevWorldCoords.copy( drag.worldCoords );

					}

				};

				// renderer

				renderer = new THREE.WebGLRenderer( { antialias: true } );
				renderer.toneMapping = THREE.ACESFilmicToneMapping;
				renderer.shadowMap.enabled = true;
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );
				renderer.setAnimationLoop( animate );
				document.body.appendChild( renderer.domElement );

				// controls

				controls = new OrbitControls( camera, renderer.domElement );
				controls.maxPolarAngle = Math.PI * 0.45;
				controls.target.set( 0, 0, 0 );
				controls.enableDamping = true;
				controls.minDistance = 5;
				controls.maxDistance = 100;

				// events

				window.addEventListener( 'pointermove', ( event ) => {

					// Convert screen coordinates to normalized device coordinates (-1 to 1)
					const rect = renderer.domElement.getBoundingClientRect();
					drag.screenCoords.x = ( ( event.clientX - rect.left ) / rect.width - 0.5 ) * 2;
					drag.screenCoords.y = - ( ( event.clientY - rect.top ) / rect.height - 0.5 ) * 2;

				} );

				renderer.domElement.addEventListener( 'pointerdown', ( event ) => {

					// Update screen coordinates immediately on pointer down
					const rect = renderer.domElement.getBoundingClientRect();
					drag.screenCoords.x = ( ( event.clientX - rect.left ) / rect.width - 0.5 ) * 2;
					drag.screenCoords.y = - ( ( event.clientY - rect.top ) / rect.height - 0.5 ) * 2;

					const intersect = drag.getIntersect();
					
					if ( intersect ) {

						renderer.domElement.style.cursor = 'grabbing';
						controls.enabled = false;
						drag.down = true;
						
						// Initialize drag coordinates
						drag.prevWorldCoords.copy( intersect.point );
						drag.worldCoords.copy( intersect.point );
						
						console.log('Drag started:', {
							screenCoords: drag.screenCoords,
							worldCoords: intersect.point
						});
			
					}

				} );

				window.addEventListener( 'pointerup', () => {

					if ( drag.down ) {
						console.log('Drag ended');
					}
					
					drag.down = false;
					controls.enabled = true;
					renderer.domElement.style.cursor = 'default';
			
				} );

				window.addEventListener( 'resize', onWindowResize );

			}

			function onWindowResize() {

				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();

				renderer.setSize( window.innerWidth, window.innerHeight );

			}

			function animate() {

				controls.update();

				drag.update();

				renderer.render( scene, camera );

			}

		</script>
	</body>
</html>
