/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
Command: npx gltfjsx@6.2.7 public/assets/models/airplane_black.glb
*/

import React, { useRef, useEffect } from 'react'
import { useGLTF } from '@react-three/drei'
import { useFrame } from '@react-three/fiber';
import { Matrix4, Quaternion, Vector3, SRGBColorSpace, Color } from 'three';
import { updatePlaneAxis, isMenuOpen } from './controls';
import { cameraRotationOffset } from './CameraDragControls';
import { getAnimatedCameraParams } from './CameraStartAnimation';

const x = new Vector3(1, 0, 0);
const y = new Vector3(0, 1, 0);
const z = new Vector3(0, 0, 1);
// Terrain size: 3455m * 0.01 scale = 34.55 units
// North border is at +terrainSize/2 (north is positive Z in this coordinate system)
const terrainSize = 34.55;
const northBorderZ = terrainSize / 2; // +17.275
export const planePosition = new Vector3(0, 3, northBorderZ);

const delayedRotMatrix = new Matrix4();
const delayedQuaternion = new Quaternion();

export function Airplane(props) {
  // thanks to:
  // https://sketchfab.com/3d-models/vintage-toy-airplane-7de2ecbc0acb4b1886c3df3d196c366b
  const gltf = useGLTF('assets/models/airplane_black.glb');
  const { nodes, materials } = gltf;
  const groupRef = useRef();
  const helixMeshRef = useRef();

  // Fix color space for all materials and textures, and configure for textures
  useEffect(() => {
    console.log('=== AIRPLANE MATERIALS DEBUG ===');
    console.log('Full GLB object:', gltf);
    console.log('Airplane materials:', materials);
    console.log('Available textures in GLB:', gltf.textures);
    console.log('Available images in GLB:', gltf.images);
    
    // Traverse scene to find all meshes and check their materials
    const meshesWithTextures = [];
    const allMeshes = [];
    gltf.scene.traverse((child) => {
      if (child.isMesh && child.material) {
        const mat = Array.isArray(child.material) ? child.material[0] : child.material;
        allMeshes.push({
          meshName: child.name || 'unnamed',
          materialName: mat.name || 'unnamed',
          hasMap: !!mat.map,
          mapName: mat.map?.name || 'none'
        });
        if (mat.map) {
          meshesWithTextures.push({
            mesh: child.name || 'unnamed',
            material: mat.name || 'unnamed',
            hasMap: !!mat.map,
            mapName: mat.map?.name || 'unnamed texture'
          });
        }
      }
    });
    console.log('ALL meshes in GLB:', allMeshes);
    console.log('Meshes with texture maps:', meshesWithTextures);
    
    Object.entries(materials).forEach(([name, material]) => {
      if (material) {
        // Check if material has textures by inspecting all texture properties
        const textureInfo = {
          map: material.map,
          normalMap: material.normalMap,
          roughnessMap: material.roughnessMap,
          metalnessMap: material.metalnessMap,
          aoMap: material.aoMap,
          emissiveMap: material.emissiveMap,
          alphaMap: material.alphaMap
        };
        
        console.log(`\nProcessing material: ${name}`, {
          type: material.type,
          originalColor: material.color ? material.color.getHexString() : 'none',
          hasMap: !!material.map,
          mapName: material.map?.name || material.map?.image?.src || 'none',
          mapImage: material.map?.image ? `${material.map.image.width}x${material.map.image.height}` : 'none',
          hasNormalMap: !!material.normalMap,
          hasRoughnessMap: !!material.roughnessMap,
          hasMetalnessMap: !!material.metalnessMap,
          hasAoMap: !!material.aoMap,
          hasEmissiveMap: !!material.emissiveMap,
          hasAlphaMap: !!material.alphaMap,
          roughness: material.roughness,
          metalness: material.metalness,
          emissive: material.emissive ? material.emissive.getHexString() : 'none',
          // Check material userData or other properties
          userData: material.userData
        });
        
        // Try to find textures in the GLB that might belong to this material
        // by checking the GLB parser's material definitions
        if (gltf.parser && gltf.parser.json) {
          const gltfJson = gltf.parser.json;
          const materialIndex = gltfJson.materials?.findIndex(m => m.name === name);
          if (materialIndex !== undefined && materialIndex >= 0) {
            const gltfMaterial = gltfJson.materials[materialIndex];
            console.log(`  GLB material definition:`, gltfMaterial);
            
            // Check for baseColorTexture
            if (gltfMaterial.pbrMetallicRoughness?.baseColorTexture) {
              const textureIndex = gltfMaterial.pbrMetallicRoughness.baseColorTexture.index;
              const texture = gltfJson.textures?.[textureIndex];
              const imageIndex = texture?.source;
              const image = gltfJson.images?.[imageIndex];
              console.log(`  Found baseColorTexture in GLB:`, {
                textureIndex,
                imageIndex,
                imageUri: image?.uri || 'embedded'
              });
            }
          }
        }
        
        // Ensure material is MeshStandardMaterial (not MeshBasicMaterial)
        if (material.type === 'MeshStandardMaterial' || material.isMeshStandardMaterial || material.isMeshPhysicalMaterial) {
          // For materials WITH textures: preserve original colors, don't force black
          // For materials WITHOUT textures: use black base color
          if (material.map) {
            console.log(`✓ Found texture map for ${name}, preserving original texture colors`);
            console.log(`  Texture details:`, {
              name: material.map.name,
              size: material.map.image ? `${material.map.image.width}x${material.map.image.height}` : 'unknown',
              originalBaseColor: material.color.getHexString()
            });
            
            // CRITICAL: Set color space for proper color rendering
            material.map.colorSpace = SRGBColorSpace;
            material.map.needsUpdate = true;
            
            // DON'T override the base color - keep it as white (0xffffff) from Blender
            // The texture will multiply with the base color
            // If base is white, texture colors show as-is
            // If base is black, texture colors get multiplied to black (wrong!)
            // So we ensure base is white for textured materials
            if (material.color.getHexString() === '111111' || material.color.getHexString() === '292929') {
              // If somehow the color got set to black, restore to white
              console.log(`  ⚠ Base color was black, restoring to white for texture visibility`);
              material.color = new Color(0xffffff);
            }
            // Otherwise, keep the original color from Blender (should be white)
            
            // Enable transparency for alpha channel (materials have alphaMode: 'BLEND')
            material.transparent = true;
            material.alphaTest = 0.01;
            material.side = 2; // DoubleSide to ensure visibility
            
            // Remove emissive to see pure texture colors first
            material.emissive = new Color(0x000000);
            material.emissiveIntensity = 0;
            material.emissiveMap = null;
            
            console.log(`  ✓ Configured: Preserved base color (${material.color.getHexString()}) + texture map`);
          } else {
            // No texture map, use black base color
            console.log(`  No texture map for ${name}, using black base color`);
            material.color = new Color('#111111');
            material.emissive = new Color(0x000000);
            material.emissiveIntensity = 0;
          }
          
          // Set color space for all texture maps
          if (material.normalMap) {
            material.normalMap.colorSpace = SRGBColorSpace;
            material.normalMap.needsUpdate = true;
          }
          if (material.roughnessMap) {
            material.roughnessMap.colorSpace = SRGBColorSpace;
            material.roughnessMap.needsUpdate = true;
          }
          if (material.metalnessMap) {
            material.metalnessMap.colorSpace = SRGBColorSpace;
            material.metalnessMap.needsUpdate = true;
          }
          if (material.aoMap) {
            material.aoMap.colorSpace = SRGBColorSpace;
            material.aoMap.needsUpdate = true;
          }
          
          // Ensure proper material properties
          material.roughness = material.roughness ?? 0.4;
          material.metalness = material.metalness ?? 0.0;
          
          // Environment map intensity
          material.envMapIntensity = material.envMapIntensity ?? 1.0;
          
          // Mark material for update
          material.needsUpdate = true;
          
          console.log(`✓ Material ${name} configured:`, {
            finalColor: material.color.getHexString(),
            hasTexture: !!material.map,
            roughness: material.roughness,
            metalness: material.metalness
          });
        }
      }
    });
    console.log('=== END MATERIALS DEBUG ===\n');
  }, [materials]);

  useFrame(({ camera }) => {
    updatePlaneAxis(x, y, z, planePosition, camera);

    const rotMatrix = new Matrix4().makeBasis(x, y, z);

    const matrix = new Matrix4()
    .multiply(new Matrix4().makeTranslation(planePosition.x, planePosition.y, planePosition.z))
    .multiply(rotMatrix);

    groupRef.current.matrixAutoUpdate = false;
    groupRef.current.matrix.copy(matrix);
    groupRef.current.matrixWorldNeedsUpdate = true;


    var quaternionA = new Quaternion().copy(delayedQuaternion);

    // warning! setting the quaternion from the rotation matrix will cause
    // issues that resemble gimbal locks, instead, always use the quaternion notation
    // throughout the slerping phase
    // quaternionA.setFromRotationMatrix(delayedRotMatrix);

    var quaternionB = new Quaternion();
    quaternionB.setFromRotationMatrix(rotMatrix);

    var interpolationFactor = 0.175;
    var interpolatedQuaternion = new Quaternion().copy(quaternionA);
    interpolatedQuaternion.slerp(quaternionB, interpolationFactor);
    delayedQuaternion.copy(interpolatedQuaternion);

    delayedRotMatrix.identity();
    delayedRotMatrix.makeRotationFromQuaternion(delayedQuaternion);

    // Base camera offset relative to airplane (behind and slightly above)
    // These are the initial values before animation starts
    // After animation completes, the final values will be used instead
    const startBaseCameraOffset = new Vector3(0, 0.1, 0.4);
    const startDownAngle = -0.35;
    
    // Get animated camera parameters
    // During animation: returns interpolated values
    // After animation completes: returns final (target) values
    // Before animation starts: returns start values
    const animatedParams = getAnimatedCameraParams(
      { x: startBaseCameraOffset.x, y: startBaseCameraOffset.y, z: startBaseCameraOffset.z },
      startDownAngle
    );
    
    const baseCameraOffset = new Vector3(
      animatedParams.offset.x,
      animatedParams.offset.y,
      animatedParams.offset.z
    );
    
    // Apply the airplane's rotation to the base offset
    // This makes the camera follow behind the airplane
    const rotatedOffset = baseCameraOffset.clone();
    rotatedOffset.applyMatrix4(delayedRotMatrix);
    
    // Apply additional rotation for the downward angle
    // Changed default: steeper downward angle for better view from above
    const downAngle = new Matrix4().makeRotationX(animatedParams.downAngle);
    rotatedOffset.applyMatrix4(downAngle);
    
    // Now apply drag rotation offsets to orbit around the airplane
    // Start with the rotated offset
    let finalOffset = rotatedOffset.clone();
    
    if (cameraRotationOffset.yaw !== 0 || cameraRotationOffset.pitch !== 0) {
      // Get the airplane's up vector (world Y or airplane's Y)
      const planeUp = new Vector3(0, 1, 0);
      planeUp.applyMatrix4(delayedRotMatrix);
      planeUp.normalize();
      
      // Get the airplane's forward vector (negative Z in airplane space)
      const planeForward = new Vector3(0, 0, -1);
      planeForward.applyMatrix4(delayedRotMatrix);
      planeForward.normalize();
      
      // Get the airplane's right vector
      const planeRight = new Vector3(1, 0, 0);
      planeRight.applyMatrix4(delayedRotMatrix);
      planeRight.normalize();
      
      // Apply yaw rotation around the airplane's up vector
      const yawQuaternion = new Quaternion().setFromAxisAngle(planeUp, cameraRotationOffset.yaw);
      finalOffset.applyQuaternion(yawQuaternion);
      
      // Apply pitch rotation around the airplane's right vector
      const pitchQuaternion = new Quaternion().setFromAxisAngle(planeRight, cameraRotationOffset.pitch);
      finalOffset.applyQuaternion(pitchQuaternion);
    }
    
    // Calculate final camera position: airplane position + offset
    const cameraPosition = planePosition.clone().add(finalOffset);
    
    // Calculate look-at target: slightly forward from airplane position along its forward direction
    // This keeps the airplane centered in view
    const lookAtOffset = new Vector3(0, 0, -0.15); // Slightly forward along airplane's forward
    lookAtOffset.applyMatrix4(delayedRotMatrix);
    const lookAtTarget = planePosition.clone().add(lookAtOffset);
    
    // Calculate the forward direction (from camera to target)
    const forward = lookAtTarget.clone().sub(cameraPosition).normalize();
    
    // Calculate right vector (cross product of forward and world up)
    const worldUp = new Vector3(0, 1, 0);
    let right = new Vector3().crossVectors(forward, worldUp).normalize();
    
    // Handle edge case where forward is parallel to world up
    if (right.length() < 0.01) {
      right = new Vector3(1, 0, 0);
    }
    
    // Calculate the actual up vector (perpendicular to both forward and right)
    const up = new Vector3().crossVectors(right, forward).normalize();
    
    // Build camera matrix: position + orientation (right, up, -forward)
    // Note: camera looks down -Z, so we use -forward
    const cameraMatrix = new Matrix4();
    cameraMatrix.makeBasis(right, up, forward.clone().negate());
    
    // Set the position (makeBasis only sets orientation, position defaults to 0,0,0)
    cameraMatrix.setPosition(cameraPosition);

    camera.matrixAutoUpdate = false;
    camera.matrix.copy(cameraMatrix);
    camera.matrixWorldNeedsUpdate = true;

    // Only rotate helix when menu is not open
    // Find helix mesh if ref is not set
    if (!helixMeshRef.current && groupRef.current && nodes.helix) {
      groupRef.current.traverse((child) => {
        if (child.isMesh && child.geometry === nodes.helix.geometry) {
          helixMeshRef.current = child;
        }
      });
    }
    
    // Rotate helix
    if (!isMenuOpen && helixMeshRef.current) {
      helixMeshRef.current.rotation.z -= 1.0;
    }
  });

  // Set helix ref after scene is loaded
  // We need to find the helix mesh in the scene after it's rendered
  useEffect(() => {
    const findHelix = () => {
      if (nodes.helix && groupRef.current) {
        // Traverse the rendered scene to find the helix mesh
        groupRef.current.traverse((child) => {
          if (child.isMesh) {
            // Check if this is the helix by comparing geometry or name
            if (child.geometry === nodes.helix.geometry || 
                child.name === 'helix' || 
                child.name.toLowerCase().includes('helix') ||
                child.name.toLowerCase().includes('propeller')) {
              helixMeshRef.current = child;
              console.log('✓ Found helix mesh:', child.name || 'unnamed');
              return;
            }
          }
        });
      }
    };
    
    // Try immediately
    findHelix();
    
    // Also try after a short delay to ensure scene is fully rendered
    const timeout = setTimeout(findHelix, 100);
    
    return () => clearTimeout(timeout);
  }, [nodes, gltf.scene]);

  return (
    <>
      <group ref={groupRef}>
        <group {...props} dispose={null} scale={0.01} rotation-y={Math.PI}>
          {/* Use the full scene from GLB to include ALL meshes (including textured ones) */}
          {/* This ensures all meshes with textures (ylmv_blanco, patagon_white, etc.) are rendered */}
          {/* Don't clone - use scene directly so material modifications apply */}
          <primitive object={gltf.scene} />
        </group>
      </group>
    </>
  )
}

useGLTF.preload('/assets/models/airplane_black.glb');
